module nwb_ast : {}

import wyvern.collections.list

type List = list.List

// Program
resource type Program
  val namedTypeDecls: List[NamedTypeDecl]
  val subtypeDecls: List[SubtypeDecl]
  val main: Expression
def Program(namedTypes: List[NamedTypeDecl], subtypes: List[SubtypeDecl], e: Expression): Program = new
  val namedTypeDecls = namedTypes
  val subtypeDecls = subtypes
  val main = e

// top level
resource type NamedTypeDecl
  val name: String
  val selfName: String
  val members: List[MemberDecl]
def NamedTypeDecl(n: String, selfName: String, members: List[MemberDecl]): NamedTypeDecl = new
  val name = n
  val selfName = selfName
  val members = members

resource type SubtypeDecl
  val subtype: String
  val lhsRefs: Refinement
  val supertype: String
def SubtypeDecl(subtype: String, lhsRefs: Refinement, supertype: String): SubtypeDecl = new
  val subtype = subtype
  val lhsRefs = lhsRefs
  val supertype = supertype

// types
resource datatype BaseType
  TOP
  BOT
  Pdt(path: Path, label: String)
  NamedType(name: String)

resource type Refinement
  val typeDecls: List[TypeMemberDecl]
def Refinement(decls: List[TypeMemberDecl]): Refinement = new
  val typeDecls = decls

resource type Type
  val baseType: BaseType
  val refinement: Refinement
def Type(base: BaseType, ref: Refinement): Type = new
  val baseType = base
  val refinement = ref

// decls
datatype Bound
  UPPER
  LOWER
  EXACT

resource type TypeMemberDecl
  val name: String
  val direction: Bound
  val bound: Type
def TypeMemberDecl(n: String, dir: Bound, tau: Type): TypeMemberDecl = new
  val name = n
  val direction = dir
  val bound = tau

resource type FieldMemberDecl
  val name: String
  val valType: Type
def FieldMemberDecl(n: String, tau: Type): FieldMemberDecl = new
  val name = n
  val valType = tau

resource type MethodMemberDecl
  val name: String
  val argType: Type
  val argName: String
  val resultType: Type
def MethodMemberDecl(n: String, argT: Type, argN: String, resT: Type): MethodMemberDecl = new
  val name = n
  val argType = argT
  val argName = argN
  val resultType = resT

resource datatype MemberDecl
  TypeMember(tdecl: TypeMemberDecl)
  FieldMember(fdecl: FieldMemberDecl)
  MethodMember(mdecl: MethodMemberDecl)

// defn
resource datatype MemberDefn
  TypeMemberDefn(name: String, t: Type)
  FieldMemberDefn(name: String, t: Type, value: Path)
  MethodMemberDefn(name: String, argType: Type, argName: String, resultType: Type, body: Expression)

// expr
resource datatype Path
  Var(name: String)
  Dot(path: Path, field: String)

resource datatype Expression
  PathExpr(path: Path)
  CallExpr(receiver: Path, method: String, argument: Path)
  NewExpr(t: Type, selfName: String, members: List[MemberDefn])
  LetExpr(varName: String, innerExpr: Expression, outerExpr: Expression)
  

/* pretty print methods */
val ppIndent: String = "  "

def ppListHelper(f: Dyn -> String, l: List[Dyn], delim: String): String
  var result: String = ""
  // turn each element into a string and append them together into result
  def appendToResult(elem: Dyn): Unit
    result = result + delim + f(elem)
  l.do((e:Dyn) => appendToResult(e))
  result

// top level
def ppProgram(prog: Program): String
  ppListHelper(x => ppNamedTypeDecl(x), prog.namedTypeDecls, "\n") + "\n\n" + \
  ppListHelper(x => ppSubtypeDecl(x), prog.subtypeDecls, "\n") + "\n\n" + \
  ppExpression(prog.main) + "\n"

def ppNamedTypeDecl(d: NamedTypeDecl): String
  d.name + " (" + d.selfName + " =>\n" + \
  ppListHelper(x => ppMemberDecl(x), d.members, "\n")

def ppSubtypeDecl(d: SubtypeDecl): String
  d.subtype + " " + ppRefinement(d.lhsRefs) + " <: " + d.supertype

// types
def ppBaseType(b: BaseType): String
  match b:
    b:TOP => "TOP"
    b:BOT => "BOT"
    b:Pdt => ppPath(b.path) + "." + b.label
    b:NamedType => b.name

def ppRefinement(r: Refinement): String
  if (r.typeDecls.length() == 0)
      ""
    else
      " {" + ppListHelper(x => ppTypeMemberDecl(x), r.typeDecls, ", ") + "}"

def ppType(t: Type): String
  ppBaseType(t.baseType) + ppRefinement(t.refinement)

// decls
def ppBound(b: Bound): String
  match b:
    b:UPPER => " <= "
    b:LOWER => " >= "
    b:EXACT => " == "

def ppTypeMemberDecl(d: TypeMemberDecl): String
  ppIndent + d.name + ppBound(d.direction) + ppType(d.bound)

def ppFieldMemberDecl(d: FieldMemberDecl): String
  ppIndent + d.name + ": " + ppType(d.valType)

def ppMethodMemberDecl(d: MethodMemberDecl): String
  ppIndent + d.name + ": " + ppType(d.argType) + " " + d.argName + " -> " + ppType(d.resultType)

def ppMemberDecl(d: MemberDecl): String
  match d:
    d:TypeMember => ppTypeMemberDecl(d.tdecl)
    d:FieldMember => ppFieldMemberDecl(d.fdecl)
    d:MethodMember => ppMethodMemberDecl(d.mdecl)

// defn
def ppMemberDefn(d: MemberDefn): String
  match d:
    d:TypeMemberDefn => ppIndent + d.name + " = " + ppType(d.t)
    d:FieldMemberDefn => ppIndent + d.name + ": " + ppType(d.t) + " = " + ppPath(d.value)
    d:MethodMemberDefn => ppIndent + d.name + ": " + ppType(d.argType) + " " + d.argName + " -> " + ppType(d.resultType) + " = " + ppExpression(d.body)

// expr
def ppPath(p: Path): String
  match p:
    p:Var => p.name
    p:Dot => ppPath(p.path) + "." + p.field

def ppExpression(e: Expression): String
  match e:
    e:PathExpr => ppPath(e.path)
    e:CallExpr => ppPath(e.receiver) + "." + e.method + "(" + ppPath(e.argument) + ")"
    e:NewExpr => "new " + ppType(e.t) + " {" + e.selfName + " =>" + ppListHelper(x => ppMemberDefn(x), e.members, ", ") + "}"
    e:LetExpr => "let " + e.varName + " = " + ppExpression(e.innerExpr) + " in " + ppExpression(e.outerExpr)
