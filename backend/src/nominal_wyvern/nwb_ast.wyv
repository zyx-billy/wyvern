module nwb_ast : {}

import wyvern.collections.list

type List = list.List

// Program
resource type Program
  val namedTypeDecls: List[NamedTypeDecl]
  val subtypeDecls: List[SubtypeDecl]
  val main: Expression
def Program(namedTypes: List[NamedTypeDecl], subtypes: List[SubtypeDecl], e: Expression): Program = new
  val namedTypeDecls = namedTypes
  val subtypeDecls = subtypes
  val main = e

// top level
resource type NamedTypeDecl
  val name: String
  val selfName: String
  val members: List[MemberDecl]
def NamedTypeDecl(n: String, selfName: String, members: List[MemberDecl]): NamedTypeDecl = new
  val name = n
  val selfName = selfName
  val members = members

resource type SubtypeDecl
  val subtype: String
  val lhsRefs: List[Refinement]
  val supertype: String
def SubtypeDecl(subtype: String, lhsRefs: List[Refinement], supertype: String): SubtypeDecl = new
  val subtype = subtype
  val lhsRefs = lhsRefs
  val supertype = supertype

// types
resource datatype BaseType
  TOP
  BOT
  Pdt(path: Path, label: String)
  NamedType(name: String)

resource type Refinement
  val typeDecls: List[TypeMemberDecl]
def Refinement(decls: List[TypeMemberDecl]): Refinement = new
  val typeDecls = decls

resource type Type
  val baseType: BaseType
  val refinement: Refinement
def Type(base: BaseType, ref: Refinement): Type = new
  val baseType = base
  val refinement = ref

// decls
datatype Bound
  UPPER
  LOWER
  EXACT

resource type TypeMemberDecl
  val name: String
  val direction: Bound
  val bound: Type
def TypeMemberDecl(n: String, dir: Bound, tau: Type): TypeMemberDecl = new
  val name = n
  val direction = dir
  val bound = tau

resource type FieldMemberDecl
  val name: String
  val valType: Type
def FieldMemberDecl(n: String, tau: Type): FieldMemberDecl = new
  val name = n
  val valType = tau

resource type MethodMemberDecl
  val name: String
  val argType: Type
  val argName: String
  val resultType: Type
def MethodMemberDecl(n: String, argT: Type, argN: String, resT: Type): MethodMemberDecl = new
  val name = n
  val argType = argT
  val argName = argN
  val resultType = resT

resource datatype MemberDecl
  TypeMember(tdecl: TypeMemberDecl)
  FieldMember(fdecl: FieldMemberDecl)
  MethodMember(mdecl: MethodMemberDecl)

// defn
resource datatype MemberDefn
  TypeMemberDefn(name: String, t: Type)
  FieldMemberDefn(name: String, t: Type, value: Path)
  MethodMemberDefn(name: String, argType: Type, argName: String, resultType: Type, body: Expression)

// expr
resource datatype Path
  Var(name: String)
  Dot(path: Path, field: String)

resource datatype Expression
  PathExpr(path: Path)
  CallExpr(receiver: Path, method: String, argument: Path)
  NewExpr(t: Type, selfName: String, members: List[MemberDefn])
  LetExpr(varName: String, innerExpr: Expression, outerExpr: Expression)
  